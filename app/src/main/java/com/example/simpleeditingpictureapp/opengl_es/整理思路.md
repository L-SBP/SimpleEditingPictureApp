# 使用OpenGL ES思路

## OpenGl ES绘图整体分为四步
1、准备数据（点、颜色、纹理坐标等）
2、将数据中的点绘画出来，三个点组成三角形，一个三角形就是一个最小单元
3、将三角形栅格化，用正方形填充模拟三角形
4、渲染，给图像上色

## 人需要做的事是：
- 准备数据，计算机不知道你想要画什么
- 渲染上色，可以自动也可主动，因为前面你已经告知了颜色信息，但是可以在这里手动做调整

因而，因为Kotlin/java代码是运行在虚拟机上的，而OpenGL ES代码是运行在硬件上的，访问不了虚拟机上的数据，怎么通信和传输数据？

通信：通过GLES30的方法可以实现，底层是JNI，JNI调用本地方法，本地方法调用OpenGL ES方法
    虚拟机代码调用 GLES30.glXXX() → JNI 把这个调用转换成本地环境能识别的 OpenGL 原生指令 → 执行 OpenGL 操作（如编译着色器、告诉 OpenGL 去哪读数据）
数据：通过java分配本地内存
    把虚拟机数组的数据复制到本地内存，OpenGL 就能直接读取这些固定地址的顶点数据。

现在OpenGL ES的代码和数据都运行在硬件上，如何把数据传递给OpenGL ES呢？
需要OpenGL管道，管道是OpenGL ES的输入输出通道，数据通过管道传递。
管道有个阶段是着色器阶段，着色器阶段是OpenGL ES的输入阶段，数据通过着色器阶段传递给OpenGL ES。
着色器代码是运行在GPU上的，需要将着色器代码传输到GPU上编译。
着色器有顶点着色器和片段着色器
顶点着色器负责计算顶点的数据
片段着色器负责计算颜色等数据
着色器代码用的是GLES语言，有点像C语言。
将着色器代码上传给GPU后，编译，然后将顶点着色器和片段着色器链接起来，得到一个着色器程序，然后将着色器程序绑定到OpenGL ES的渲染管线中

综上，思路就是
- 准备好数据，然后复制到本地内存
- 编写两个着色器代码
- 通过GLES30的方法将两个着色器代码上传、编译、连接、绑定
- 通过GLES30的方法和着色器，告诉OpenGL ES去本地的哪里读数据
- 通过GLES30的方法开始渲染

opengl提供了GLSurfaceView和Renderer
GLSurfaceView是OpenGL ES的显示容器，GLSurfaceView会创建一个OpenGL ES的渲染线程，GLSurfaceView会调用Renderer的onSurfaceCreated()和和onDrawFrame()方法
Renderer是OpenGL ES的渲染器，是一个接口，需要实现这个接口，并实现onSurfaceCreated()和onDrawFrame()方法